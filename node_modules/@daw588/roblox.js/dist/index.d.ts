// Generated by dts-bundle-generator v8.1.0

/**
 * 8 bytes
 */
export type int64 = number;
/**
 * 4 bytes
 */
export type int32 = number;
export type Prefix = {
	/**
	 * Return only data stores with this prefix.
	 */
	prefix?: string;
};
export type Cursor = {
	/**
	 * Provide to request the next set of data.
	 *
	 * **The format of cursor strings is not defined. You should not interpret or parse them as they may change at any time.**
	 */
	cursor?: string;
};
export type Limit = {
	/**
	 * Maximum number of items to return.
	 */
	limit?: int32;
};
export type DataStoreName = {
	/**
	 * Name of the data store.
	 */
	datastoreName: string;
};
export type Scope = {
	/**
	 * Defaults to global, similar to Lua API.
	 */
	scope?: string;
};
export type EntryKey = {
	/**
	 * The key which identifies the entry.
	 *
	 * *Roblox's documentation does not state whether its required or not, so for now its marked as required.*
	 */
	entryKey: string;
};
export type StartTime = {
	/**
	 * Time string in (ISO datetime, UTC) format. Don't consider versions older than this.
	 */
	startTime?: string;
};
export type EndTime = {
	/**
	 * Time string in (ISO datetime, UTC) format. Don't consider versions younger than this.
	 */
	endTime?: string;
};
export type SortOrder = {
	/**
	 * Either Ascending (older first) or Descending (younger first).
	 */
	sortOrder?: string;
};
export type AllScopes = {
	/**
	 * If true, return keys from all scopes.
	 */
	AllScopes?: boolean;
};
export type ListDataStores = Prefix & Limit & Cursor;
export type ListEntries = DataStoreName & Scope & AllScopes & Prefix & Limit & Cursor;
export type ListEntryVersions = Limit & Cursor & DataStoreName & Scope & EntryKey & StartTime & EndTime & SortOrder;
export type EntryVersionInfo = {
	version: string;
	deleted: boolean;
	contentLength: int32;
	createdTime: string;
	objectCreatedTime: string;
};
export type DataStoreInfo = {
	name: string;
	createdTime: string;
};
export type EntryKeyInfo = {
	scope: string;
	key: string;
};
export type PaginationParams<ExtendType> = ExtendType & {
	cursor?: string;
	limit?: int32;
};
export type PaginationHeader<ExtendType> = ExtendType & Record<string, string>;
declare class Pages<QueryParams, Headers, ItemData> {
	/**
	 * Whether or not the current page is the last page available.
	 */
	isFinished: boolean;
	private keys;
	private params;
	private readonly keyName;
	private readonly rawUrl;
	private readonly headers;
	constructor(keyName: string, rawUrl: string, params: PaginationParams<QueryParams>, headers: PaginationHeader<Headers>);
	GetCurrentPageAsync(): Promise<ItemData[]>;
	/**
	 * Iterates to the next page in the pages object, if possible.
	 */
	AdvanceToNextPageAsync(): Promise<undefined>;
}
export type XApiKey = {
	/**
	 * The API key
	 */
	"x-api-key": string;
};
/**
 * Universe is a collection of places, often referred
 * to as a game or an experience.
 */
export declare class Universe {
	readonly id: int64;
	readonly apiKey: string;
	/**
	 * @param id Universe's id. Do not mistake it for place id.
	 * @param apiKey API key; is used to authenticate API calls made to the universe.
	 */
	constructor(id: int64, apiKey: string);
	/**
	 * Returns a `DataStoreListingPages` class for enumerating through all of the universe's data stores.
	 * It accepts an optional prefix parameter to only locate data stores whose names start with the provided prefix.
	 * @param prefix Prefix to enumerate data stores that start with the given prefix.
	 * @param pageSize Number of items to be returned in each page.
	 * @returns `DataStoreListingPages` class containing `DataStoreInfo` objects that provide details such as name, creation time, ~~and time last updated~~.
	 */
	ListDataStoresAsync(prefix?: string, pageSize?: int32): Promise<Pages<DataStoreQueryParams.ListDataStores, XApiKey, DataStoreResponseJSON.DataStoreInfo>>;
	/**
	 * This function sends the provided message to all subscribers to the topic,
	 * triggering their registered callbacks to be invoked.
	 *
	 * Same as MessagingService:PublishAsync()
	 * @param topic Determines where the message is sent.
	 * @param message The data to include in the message.
	 */
	PublishMessageAsync(topic: string, message: string): Promise<string>;
}
/**
 * Place is a collection of environmental building blocks,
 * models, scripts, UI, game logic, and everything else related
 * to the game's experience.
 */
export declare class Place {
	readonly universe: Universe;
	readonly id: int64;
	private readonly url;
	/**
	 * @param universe Refers to the universe to which place belongs to.
	 * @param id Place's id.
	 */
	constructor(universe: Universe, id: int64);
	/**
	 * Uploads the place file via desired method to Roblox.
	 * @param path Path to the place file.
	 * @returns The latest version that was saved and/or published.
	 */
	private PushVersion;
	/**
	 * Uploads and saves the place file to Roblox.
	 *
	 * **Changes caused by this function will be
	 * only visible to the developers.**
	 *
	 * @param path Path to the place file.
	 * @returns The latest version that was saved.
	 */
	SaveAs(path: string): Promise<number>;
	/**
	 * Uploads, saves, and publishes the place file to Roblox.
	 *
	 * **Changes caused by this function will be
	 * visible to both players and the developers.**
	 *
	 * @param path Path to the place file.
	 * @returns The latest version that was saved and published.
	 */
	PublishAs(path: string): Promise<number>;
}
export type SortDirection = "Ascending" | "Descending";
export type Params = {
	[key: string]: string | number | boolean;
};
export declare class DataStoreKeyInfo {
	readonly createdTime: number;
	readonly version: string;
	private readonly userIds;
	private readonly metadata;
	constructor(response: Response);
	GetUserIds(): number[];
	GetMetadata(): utils.Params;
}
export declare class DataStoreSetOptions {
	metadata: Record<string, string>;
	constructor(metadata: Record<string, string>);
	GetMetadata(): Record<string, string>;
	SetMetadata(metadata: Record<string, string>): void;
}
export declare class DataStoreOptions {
	allScopes: boolean;
}
/**
 * Lets you store data that needs to persist between sessions,
 * such as items in a player's inventory or skill points. DataStores
 * are shared per experience, so any place in an experience, including
 * places on different servers, can access and change the same data.
 */
export declare class DataStore {
	readonly universe: Universe;
	readonly name: string;
	readonly scope: string;
	readonly options: DataStoreOptions;
	private readonly url;
	/**
	 * @param universe Universe from which DataStore will be retrieved.
	 * @param name Name of the data store.
	 * @param scope A string specifying the scope.
	 */
	constructor(universe: Universe, name: string, scope?: string, options?: DataStoreOptions);
	/**
	 * This function returns the latest value of the provided key and a `DataStoreKeyInfo` class.
	 * If the key does not exist or if the latest version has been marked as deleted, both return values will be `null`.
	 * @param key The key name for which the value is requested.
	 * @returns The value of the entry in the data store with the given key and a `DataStoreKeyInfo`
	 * class that includes the version number, date and time the version was created, and functions to retrieve UserIds and metadata.
	 */
	GetAsync<CustomDataType>(key: string): Promise<[
		CustomDataType,
		DataStoreKeyInfo
	]>;
	/**
	 * This function sets the latest value, UserIds, and metadata for the given key.
	 *
	 * **Metadata definitions must always be updated with a value, even if there are no changes to the current value; otherwise the current value will be lost.**
	 * @param key Key name for which the value should be set.
	 * @param value The value that the data store key will be set to.
	 * @param userIds Table of `UserIds`, highly recommended to assist with GDPR tracking/removal.
	 * @param options Class that allows for metadata specification on the key.
	 * @returns The version identifier of the newly created version
	 */
	SetAsync<CustomDataType>(key: string, value: CustomDataType, userIds?: int64[], options?: DataStoreSetOptions): Promise<string>;
	/**
	 * This function increments the value of a key by the provided amount (both must be integers).
	 * @param key Key name for which the value should be updated.
	 * @param delta Amount to increment the current value by.
	 * @param userIds A table of `UserIds` to associate with the key.
	 * @param options Class that combines multiple additional parameters as custom metadata and allows for future extensibility.
	 * @returns The updated value of the entry in the data store with the given key.
	 */
	IncrementAsync<CustomDataType>(key: string, delta: int32, userIds?: int64[], options?: DataStoreSetOptions): Promise<[
		CustomDataType,
		DataStoreKeyInfo
	]>;
	/**
	 * This function marks the specified key as deleted by creating a new "tombstone" version of the key.
	 * @param key Key name to be removed.
	 * @returns The value of the data store prior to deletion and a `DataStoreKeyInfo` class.
	 */
	RemoveAsync(key: string): Promise<[
		unknown,
		DataStoreKeyInfo
	]>;
	/**
	 * This function returns a `DataStoreKeyPages` object for enumerating through keys of a data store.
	 * It accepts an optional `prefix` parameter to only locate keys whose names start with the provided `prefix`.
	 * @param prefix Prefix to use for locating keys.
	 * @param pageSize Number of items to be returned in each page.
	 * @returns A `DataStoreKeyPages` instance that enumerates the keys as DataStoreKey instances.
	 */
	ListKeysAsync(prefix?: string, pageSize?: int32): Promise<Pages<QueryParams.ListEntries, XApiKey, ResponseJSON.EntryKeyInfo>>;
	/**
	 * This function enumerates versions of the specified key in either ascending or descending order specified by a SortDirection parameter.
	 * It can optionally filter the returned versions by minimum and maximum timestamp.
	 * @param key Key name for the versions to list.
	 * @param sortDirection Sort order of the versions.
	 * @param minDate Date after which the versions should be listed.
	 * @param maxDate Date up to which the versions should be listed.
	 * @param pageSize Number of items to be returned in each page.
	 * @returns A `DataStoreVersionPages` class that enumerates all the versions of the key as `DataStoreObjectVersionInfo` classes.
	 */
	ListVersionsAsync(key: string, sortDirection?: SortDirection, minDate?: int64, maxDate?: int64, pageSize?: int32): Promise<Pages<QueryParams.ListEntryVersions, XApiKey, ResponseJSON.EntryVersionInfo>>;
	/**
	 * This function retrieves the specified key version as well as a `DataStoreKeyInfo` instance.
	 * @param key Key name for which the version info is requested.
	 * @param version Version number of the key for which the version info is requested.
	 * @returns The value of the entry in the data store with the given key and a `DataStoreKeyInfo`
	 * class that includes the version number, date and time the version was created, and functions to retrieve UserIds and metadata.
	 */
	GetVersionAsync<CustomDataType>(key: string, version: string): Promise<(DataStoreKeyInfo | CustomDataType)[]>;
}
export type ListReturn = {
	entries: {
		path: string;
		value: number;
		id: string;
	}[];
	nextPageToken: string;
};
export type DataStoreListingInfo = {
	universe: Universe;
	name: string;
	scope: string;
	ascending: boolean;
	pageSize: number;
};
export declare class DataStorePages {
	private entries;
	private readonly info;
	private nextPageToken;
	IsFinished: boolean;
	constructor(info: DataStoreListingInfo, data: raw.ListReturn);
	GetCurrentPage(): {
		key: string;
		value: number;
	}[];
	AdvanceToNextPageAsync(): Promise<void>;
}
export declare class OrderedDataStore {
	readonly universe: Universe;
	private readonly name;
	private readonly scope;
	constructor(universe: Universe, name: string, scope?: string);
	GetSortedAsync(ascending: boolean, pageSize: number): Promise<DataStorePages>;
	SetAsync(key: string, value: number): Promise<void>;
	GetAsync(key: string): Promise<number>;
	RemoveAsync(key: string): Promise<void>;
}

export {};
