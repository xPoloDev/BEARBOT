// src/lib/http.tsg
import crypto from "node:crypto";
function buildUrl(url, params) {
  const urlObj = new URL(url);
  Object.keys(params).forEach((key) => urlObj.searchParams.append(key, params[key]));
  return urlObj;
}
function checksum(value) {
  return crypto.createHash("md5").update(value).digest("base64");
}
function mustBeInteger(what, value) {
  if (typeof value !== "number" || !Number.isInteger(value)) {
    throw Error(`${what} must be an integer`);
  }
}
function mustBeString(what, value) {
  if (typeof value !== "string") {
    throw Error(`${what} must be a string`);
  }
}
function replaceOnceAfter(str, search, replace, afterIndex) {
  return str.slice(0, afterIndex) + str.slice(afterIndex).replace(search, replace);
}
function parseJSON(text) {
  let insideQuotes = false;
  for (let i = 0;i < text.length; i++) {
    if (text[i] === "i" && text[i + 1] === "n" && text[i + 2] === "f" && !insideQuotes) {
      text = replaceOnceAfter(text, "inf", "1e500", i);
    } else if (text[i - 1] !== "\\" && text[i] === "\"") {
      insideQuotes = !insideQuotes;
    }
  }
  return JSON.parse(text);
}

// src/lib/http.tsges.ts
class Pages {
  isFinished = false;
  keys;
  params;
  keyName;
  rawUrl;
  headers;
  constructor(keyName, rawUrl, params, headers) {
    this.rawUrl = rawUrl;
    this.params = params;
    this.headers = headers;
    this.keyName = keyName;
  }
  async GetCurrentPageAsync() {
    if (!this.params.cursor) {
      await this.AdvanceToNextPageAsync();
      return this.keys;
    }
    return this.keys;
  }
  async AdvanceToNextPageAsync() {
    if (this.isFinished)
      throw Error("Next page was not found");
    const url = buildUrl(this.rawUrl, this.params);
    const response = await fetch(url, {
      method: "get",
      headers: this.headers
    });
    if (response.status !== 200) {
      return Promise.reject({
        status: response.status,
        statusText: response.statusText
      });
    }
    const data = parseJSON(await response.text());
    const newKeys = data[this.keyName];
    if (newKeys) {
      this.keys = newKeys;
    }
    if (!data.nextPageCursor) {
      this.isFinished = true;
      return;
    }
    this.params.cursor = data.nextPageCursor;
    return;
  }
}

// src/lib/http.tsges
var DATA_STORE = "https://apis.roblox.com/datastores/v1/universes";
var ORDERED_DATA_STORE = "https://apis.roblox.com/ordered-data-stores";
var PLACE_MANAGEMENT = "https://apis.roblox.com/universes/v1";
var MESSAGING_SERVICE = "https://apis.roblox.com/messaging-service/v1/universes";

// src/lib/http.tsges.ts-da
class Universe {
  id;
  apiKey;
  constructor(id, apiKey) {
    this.id = id;
    this.apiKey = apiKey;
  }
  async ListDataStoresAsync(prefix = "", pageSize = 50) {
    mustBeString("Prefix", prefix);
    mustBeInteger("PageSize", pageSize);
    if (pageSize > 50)
      throw Error("PageSize cannot be greater than 50");
    const rawUrl = `${DATA_STORE}/${this.id}/standard-datastores`;
    const queryParams = {
      limit: pageSize,
      prefix
    };
    const headers = {
      "x-api-key": this.apiKey
    };
    return new Pages("datastores", rawUrl, queryParams, headers);
  }
  async PublishMessageAsync(topic, message) {
    mustBeString("Topic", topic);
    mustBeString("Message", message);
    if (!topic.match(new RegExp("^[a-zA-Z0-9]*$"))) {
      throw Error("Topic name cannot contain non-alphanumeric characters");
    }
    if (topic.length > 80) {
      throw Error("Topic name cannot contain more than 80 characters");
    }
    const url = `${MESSAGING_SERVICE}/${this.id}/topics/${topic}`;
    const valueJSON = JSON.stringify({
      message
    });
    const headers = {
      "x-api-key": this.apiKey,
      "Content-Type": "application/json"
    };
    const response = await fetch(url, {
      method: "post",
      headers,
      body: valueJSON
    });
    if (response.status !== 200) {
      return Promise.reject({
        status: response.status,
        statusText: response.statusText
      });
    }
    return await response.text();
  }
}
// src/lib/http.tsges.ts
import fs from "node:fs/promises";
class Place {
  universe;
  id;
  url;
  constructor(universe, id) {
    this.universe = universe;
    this.id = id;
    this.url = `${PLACE_MANAGEMENT}/${this.universe.id}/places/${this.id}`;
  }
  async PushVersion(path, versionType) {
    mustBeString("Path", path);
    mustBeString("VersionType", versionType);
    try {
      await fs.access(path);
    } catch (e) {
      throw Error("Place file either does not exist, or there is something restricting the access to it");
    }
    const fileInfo = await fs.stat(path);
    const fileSizeInBytes = fileInfo.size;
    const fileSizeInMegabytes = fileSizeInBytes / 1048576;
    if (fileSizeInMegabytes >= 100) {
      throw Error("Place file cannot be larger than 100MB");
    }
    const fileData = await fs.readFile(path);
    const queryParams = {
      versionType
    };
    const url = buildUrl(this.url + "/versions", queryParams);
    const headers = {
      "x-api-key": this.universe.apiKey,
      "Content-Type": "application/octet-stream"
    };
    const response = await fetch(url, {
      method: "post",
      headers,
      body: fileData
    });
    if (response.status !== 200) {
      return Promise.reject({
        status: response.status,
        statusText: response.statusText
      });
    }
    const data = parseJSON(await response.text());
    return data.versionNumber;
  }
  async SaveAs(path) {
    return this.PushVersion(path, "Saved");
  }
  async PublishAs(path) {
    return this.PushVersion(path, "Published");
  }
}
// src/lib/http.tsges.ts-data
class DataStoreKeyInfo {
  createdTime;
  version;
  userIds;
  metadata;
  constructor(response) {
    const createdTime = response.headers.get("roblox-entry-created-time");
    const version = response.headers.get("roblox-entry-version");
    const metadata = response.headers.get("roblox-entry-attributes");
    const userIds = response.headers.get("roblox-entry-userids");
    this.createdTime = new Date(createdTime).getTime();
    this.version = version;
    this.userIds = JSON.parse(userIds);
    this.metadata = JSON.parse(metadata);
  }
  GetUserIds() {
    return this.userIds;
  }
  GetMetadata() {
    return this.metadata;
  }
}

class DataStoreSetOptions {
  metadata;
  constructor(metadata) {
    this.metadata = metadata;
  }
  GetMetadata() {
    return this.metadata;
  }
  SetMetadata(metadata) {
    this.metadata = metadata;
  }
}

class DataStoreOptions {
  allScopes = false;
}

class DataStore {
  universe;
  name;
  scope;
  options;
  url;
  constructor(universe, name, scope = "global", options) {
    this.universe = universe;
    this.name = name;
    this.scope = scope;
    this.options = options || new DataStoreOptions;
    this.url = `${DATA_STORE}/${this.universe.id}/standard-datastores/datastore`;
  }
  async GetAsync(key) {
    mustBeString("Key", key);
    const queryParams = {
      datastoreName: this.name,
      entryKey: key
    };
    const url = buildUrl(this.url + "/entries/entry", queryParams);
    const headers = {
      "x-api-key": this.universe.apiKey
    };
    const response = await fetch(url, {
      method: "get",
      headers
    });
    if (response.status !== 200) {
      return Promise.reject({
        status: response.status,
        statusText: response.statusText
      });
    }
    const data = parseJSON(await response.text());
    return [data, new DataStoreKeyInfo(response)];
  }
  async SetAsync(key, value, userIds = [], options) {
    mustBeString("Key", key);
    if (value == undefined || null)
      throw Error("Value cannot be empty");
    const queryParams = {
      datastoreName: this.name,
      scope: this.scope,
      entryKey: key
    };
    const url = buildUrl(this.url + "/entries/entry", queryParams);
    const valueJSON = JSON.stringify(value);
    const dataSizeMB = Buffer.from(valueJSON).byteLength / 1e6;
    if (dataSizeMB >= 4)
      throw Error("Value cannot be larger than 4MB");
    const headers = {
      "x-api-key": this.universe.apiKey,
      "content-md5": checksum(valueJSON),
      "roblox-entry-userids": JSON.stringify(userIds),
      "roblox-entry-attributes": options ? JSON.stringify(options.GetMetadata()) : ""
    };
    const response = await fetch(url, {
      method: "post",
      headers,
      body: valueJSON
    });
    if (response.status !== 200) {
      return Promise.reject({
        status: response.status,
        statusText: response.statusText
      });
    }
    const data = parseJSON(await response.text());
    return data.version;
  }
  async IncrementAsync(key, delta, userIds = [], options) {
    mustBeString("Key", key);
    mustBeInteger("Delta", delta);
    const queryParams = {
      datastoreName: this.name,
      scope: this.scope,
      entryKey: key,
      incrementBy: delta
    };
    const url = buildUrl(this.url + "/entries/entry/increment", queryParams);
    const headers = {
      "x-api-key": this.universe.apiKey,
      "roblox-entry-userids": JSON.stringify(userIds),
      "roblox-entry-attributes": options ? JSON.stringify(options.GetMetadata()) : ""
    };
    const response = await fetch(url, {
      method: "post",
      headers
    });
    if (response.status !== 200) {
      return Promise.reject({
        status: response.status,
        statusText: response.statusText
      });
    }
    const data = await this.GetAsync(key);
    return data;
  }
  async RemoveAsync(key) {
    mustBeString("Key", key);
    const previousData = await this.GetAsync(key);
    const queryParams = {
      datastoreName: this.name,
      scope: this.scope,
      entryKey: key
    };
    const url = buildUrl(this.url + "/entries/entry", queryParams);
    const headers = {
      "x-api-key": this.universe.apiKey
    };
    const response = await fetch(url, {
      method: "delete",
      headers
    });
    if (response.status !== 204) {
      return Promise.reject({
        status: response.status,
        statusText: response.statusText
      });
    }
    return previousData;
  }
  async ListKeysAsync(prefix = "", pageSize = 50) {
    mustBeString("Prefix", prefix);
    mustBeInteger("PageSize", pageSize);
    if (pageSize > 50)
      throw Error("PageSize cannot be greater than 50");
    const rawUrl = this.url + "/entries";
    const queryParams = {
      datastoreName: this.name,
      scope: this.scope,
      AllScopes: this.options.allScopes,
      limit: pageSize,
      prefix
    };
    const headers = {
      "x-api-key": this.universe.apiKey
    };
    return new Pages("keys", rawUrl, queryParams, headers);
  }
  async ListVersionsAsync(key, sortDirection = "Ascending", minDate = 0, maxDate = 0, pageSize = 50) {
    mustBeString("Key", key);
    mustBeString("SortDirection", sortDirection);
    mustBeInteger("MinDate", minDate);
    mustBeInteger("MaxDate", maxDate);
    mustBeInteger("PageSize", pageSize);
    if (sortDirection !== "Ascending" && sortDirection !== "Descending") {
      throw Error("SortDirection must be either Ascending or Descending");
    }
    const rawUrl = this.url + "/entries/entry/versions";
    const queryParams = {
      datastoreName: this.name,
      scope: this.scope,
      entryKey: key,
      sortOrder: sortDirection,
      limit: pageSize
    };
    if (minDate !== 0)
      queryParams.startTime = new Date(minDate).toISOString();
    if (maxDate !== 0)
      queryParams.endTime = new Date(maxDate).toISOString();
    const headers = {
      "x-api-key": this.universe.apiKey
    };
    return new Pages("versions", rawUrl, queryParams, headers);
  }
  async GetVersionAsync(key, version) {
    mustBeString("Key", key);
    mustBeString("Version", version);
    const queryParams = {
      datastoreName: this.name,
      entryKey: key,
      versionId: version
    };
    const url = buildUrl(this.url + "/entries/entry/versions/version", queryParams);
    const headers = {
      "x-api-key": this.universe.apiKey
    };
    const response = await fetch(url, {
      method: "get",
      headers
    });
    if (response.status !== 200) {
      return Promise.reject({
        status: response.status,
        statusText: response.statusText
      });
    }
    const data = parseJSON(await response.text());
    return [data, new DataStoreKeyInfo(response)];
  }
}
// src/lib/http.ts
async function request(info) {
  const query = new URLSearchParams;
  for (const [key, value] of Object.entries(info.query)) {
    if (value) {
      if (typeof value === "string") {
        query.append(key, value);
      } else if (typeof value === "number" || typeof value === "boolean") {
        query.append(key, value.toString());
      }
    }
  }
  const response = await fetch(info.url + "?" + query.toString(), {
    method: info.method,
    headers: info.headers,
    body: info.body
  });
  return response;
}

// src/lib/http.tsges.ts-data-store.ts
async function listEntries({
  xApiKey,
  universeId,
  orderedDataStore,
  scope,
  maxPageSize,
  pageToken,
  orderBy,
  filter
}) {
  const response = await request({
    url: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries`,
    method: "GET",
    headers: {
      "x-api-key": xApiKey
    },
    query: {
      max_page_size: maxPageSize,
      page_token: pageToken,
      order_by: orderBy,
      filter
    }
  });
  return await response.json();
}
async function createEntry({
  xApiKey,
  universeId,
  orderedDataStore,
  scope,
  id,
  value
}) {
  const response = await request({
    url: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries`,
    method: "POST",
    headers: {
      "x-api-key": xApiKey,
      "Content-Type": "application/json"
    },
    query: {
      id
    },
    body: JSON.stringify({
      value
    })
  });
  return await response.json();
}
async function getEntry({
  xApiKey,
  universeId,
  orderedDataStore,
  scope,
  entry
}) {
  const response = await request({
    url: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries/${entry}`,
    method: "GET",
    headers: {
      "x-api-key": xApiKey
    },
    query: {}
  });
  return await response.json();
}
async function deleteEntry({
  xApiKey,
  universeId,
  orderedDataStore,
  scope,
  entry
}) {
  await request({
    url: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries/${entry}`,
    method: "DELETE",
    headers: {
      "x-api-key": xApiKey
    },
    query: {}
  });
}

// src/lib/http.tsges.ts-data-store.t
class DataStorePages {
  entries;
  info;
  nextPageToken;
  IsFinished;
  constructor(info, data) {
    this.info = info;
    this.entries = data.entries;
    this.nextPageToken = data.nextPageToken;
    this.IsFinished = this.nextPageToken === "";
  }
  GetCurrentPage() {
    return this.entries.map((v) => {
      return {
        key: v.id,
        value: v.value
      };
    });
  }
  async AdvanceToNextPageAsync() {
    if (this.IsFinished)
      return;
    const response = await listEntries({
      xApiKey: this.info.universe.apiKey,
      universeId: this.info.universe.id.toString(),
      orderedDataStore: this.info.name,
      scope: this.info.scope,
      orderBy: this.info.ascending ? "asc" : "desc",
      maxPageSize: this.info.pageSize,
      pageToken: this.nextPageToken
    });
    this.entries = response.entries;
    this.nextPageToken = response.nextPageToken;
    this.IsFinished = this.nextPageToken === "";
  }
}

class OrderedDataStore {
  universe;
  name;
  scope;
  constructor(universe, name, scope = "global") {
    this.universe = universe;
    this.name = name;
    this.scope = scope;
  }
  async GetSortedAsync(ascending, pageSize) {
    const data = await listEntries({
      xApiKey: this.universe.apiKey,
      universeId: this.universe.id.toString(),
      orderedDataStore: this.name,
      scope: this.scope,
      orderBy: ascending ? "asc" : "desc",
      maxPageSize: pageSize
    });
    const info = {
      universe: this.universe,
      name: this.name,
      scope: this.scope,
      ascending,
      pageSize
    };
    return new DataStorePages(info, data);
  }
  async SetAsync(key, value) {
    await createEntry({
      xApiKey: this.universe.apiKey,
      universeId: this.universe.id.toString(),
      orderedDataStore: this.name,
      scope: this.scope,
      id: key,
      value
    });
  }
  async GetAsync(key) {
    const data = await getEntry({
      xApiKey: this.universe.apiKey,
      universeId: this.universe.id.toString(),
      orderedDataStore: this.name,
      scope: this.scope,
      entry: key
    });
    return data.value;
  }
  async RemoveAsync(key) {
    await deleteEntry({
      xApiKey: this.universe.apiKey,
      universeId: this.universe.id.toString(),
      orderedDataStore: this.name,
      scope: this.scope,
      entry: key
    });
  }
}
export {
  Universe,
  Place,
  OrderedDataStore,
  DataStoreSetOptions,
  DataStorePages,
  DataStoreOptions,
  DataStoreKeyInfo,
  DataStore
};

//# debugId=7D7AAEF9F35C710264756e2164756e21
