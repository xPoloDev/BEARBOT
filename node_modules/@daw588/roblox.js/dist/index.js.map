{
  "version": 3,
  "sources": ["../src/lib/utils.ts", "../src/api/luau/pages.ts", "../src/config/urls.ts", "../src/api/luau/universe.ts", "../src/api/luau/place.ts", "../src/api/luau/place.ts", "../src/api/luau/data-store.ts", "../src/lib/http.ts", "../src/api/cloud/ordered-data-store.ts", "../src/api/luau/ordered-data-store.ts"],
  "sourcesContent": [
    "import crypto from \"node:crypto\";\r\n\r\nexport type Params = { \r\n\t[key: string]: string | number | boolean\r\n}\r\n\r\nexport type ParamsKey = keyof Params;\r\n\r\nexport function buildUrl(url: string, params: Params) {\r\n\tconst urlObj = new URL(url);\r\n\tObject.keys(params).forEach(key => urlObj.searchParams.append(key, params[key] as keyof ParamsKey));\r\n\treturn urlObj;\r\n}\r\n\r\nexport function checksum(value: crypto.BinaryLike) {\r\n\treturn crypto.createHash(\"md5\").update(value).digest(\"base64\");\r\n}\r\n\r\nexport function mustBeInteger(what: string, value: number) {\r\n\tif (typeof(value) !== \"number\" || !Number.isInteger(value)) {\r\n\t\tthrow Error(`${what} must be an integer`);\r\n\t}\r\n}\r\n\r\nexport function mustBeString(what: string, value: string) {\r\n\tif (typeof(value) !== \"string\") {\r\n\t\tthrow Error(`${what} must be a string`);\r\n\t}\r\n}\r\n\r\nexport function replaceOnceAfter(str: string, search: string, replace: string, afterIndex: number) {\r\n\treturn str.slice(0, afterIndex) + str.slice(afterIndex).replace(search, replace);\r\n}\r\n\r\nexport function parseJSON(text: string) {\r\n\t/*\r\n\t\tReplace all Roblox's inf values with 1e500\r\n\t\tto represent JavaScript's Infinity value,\r\n\t\totherwise JSON errors will be thrown at us.\r\n\t*/\r\n\tlet insideQuotes = false;\r\n\tfor (let i = 0; i < text.length; i++) {\r\n\t\t// Make sure to catch every inf that is outside of quotes\r\n\t\tif (text[i] === \"i\" && text[i + 1] === \"n\" && text[i + 2] === \"f\" && !insideQuotes) {\r\n\t\t\t// Replace inf with 1e500\r\n\t\t\ttext = replaceOnceAfter(text, \"inf\", \"1e500\", i);\r\n\t\t} else if (text[i - 1] !== \"\\\\\" && text[i] === \"\\\"\") {\r\n\t\t\tinsideQuotes = !insideQuotes;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Return parsed JSON\r\n\treturn JSON.parse(text);\r\n}\r\n",
  "import type { int32 } from \"../../types/misc/datatypes\";\r\nimport * as utils from \"../../lib/utils\";\r\n\r\ntype PaginationParams<ExtendType> = ExtendType & {\r\n\tcursor?: string,\r\n\tlimit?: int32\r\n}\r\n\r\n// TODO: Fix this type to take ResponseData type instead of ItemData type\r\ntype PaginationData<ExtendType> = {\r\n\t[key: string]: ExtendType[]\r\n} & {\r\n\tnextPageCursor: string | null\r\n}\r\n\r\ntype PaginationHeader<ExtendType> = ExtendType & Record<string, string>;\r\n\r\nexport class Pages<QueryParams, Headers, ItemData> {\r\n\t/**\r\n\t * Whether or not the current page is the last page available.\r\n\t */\r\n\tpublic isFinished = false;\r\n\r\n\tprivate keys!: ItemData[];\r\n\tprivate params!: PaginationParams<QueryParams>;\r\n\tprivate readonly keyName!: string;\r\n\tprivate readonly rawUrl!: string;\r\n\tprivate readonly headers!: PaginationHeader<Headers>;\r\n\r\n\t/*\r\n\t\tType Structure Help\r\n\r\n\t\tQueryParams\r\n\t\t{\r\n\t\t\tdatastoreName: string,\r\n\t\t\tscope: string,\r\n\t\t\tAllScopes: boolean,\r\n\t\t\tlimit: string,\r\n\t\t\tprefix: string,\r\n\t\t\tcursor: string\r\n\t\t}\r\n\r\n\t\tHeaders\r\n\t\t{\r\n\t\t\tx-api-key\r\n\t\t}\r\n\r\n\t\tResponse Data\r\n\t\t{\r\n\t\t\tkeys: ItemData[],\r\n\t\t\tnextPageCursor: string | null\r\n\t\t}\r\n\r\n\t\tItemData\r\n\t\t{\r\n\t\t\tkey: string,\r\n\t\t\tscope: string\r\n\t\t}\r\n\t*/\r\n\r\n\tconstructor(keyName: string, rawUrl: string, params: PaginationParams<QueryParams>, headers: PaginationHeader<Headers>) {\r\n\t\tthis.rawUrl = rawUrl;\r\n\t\tthis.params = params;\r\n\t\tthis.headers = headers;\r\n\t\tthis.keyName = keyName;\r\n\t}\r\n\r\n\tasync GetCurrentPageAsync() {\r\n\t\t// Have we gotten our first page yet?\r\n\t\tif (!this.params.cursor) {\r\n\t\t\t// Get the initial/first page\r\n\t\t\tawait this.AdvanceToNextPageAsync();\r\n\t\t\treturn this.keys;\r\n\t\t}\r\n\t\treturn this.keys;\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates to the next page in the pages object, if possible.\r\n\t */\r\n\tasync AdvanceToNextPageAsync() {\r\n\t\tif (this.isFinished) throw Error(\"Next page was not found\");\r\n\r\n\t\tconst url = utils.buildUrl(this.rawUrl, this.params);\r\n\t\t\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"get\",\r\n\t\t\theaders: this.headers\r\n\t\t});\r\n\r\n\t\tif (response.status !== 200) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tconst data = utils.parseJSON(await response.text()) as PaginationData<ItemData>;\r\n\r\n\t\t// Update the keys\r\n\t\tconst newKeys = data[this.keyName];\r\n\t\tif (newKeys) {\r\n\t\t\tthis.keys = newKeys;\r\n\t\t}\r\n\r\n\t\tif (!data.nextPageCursor) {\r\n\t\t\tthis.isFinished = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// Go to the next page via cursor\r\n\t\tthis.params.cursor = data.nextPageCursor;\r\n\t\treturn;\r\n\t}\r\n}\r\n",
  "export const DATA_STORE = \"https://apis.roblox.com/datastores/v1/universes\";\r\nexport const ORDERED_DATA_STORE = \"https://apis.roblox.com/ordered-data-stores\";\r\nexport const PLACE_MANAGEMENT = \"https://apis.roblox.com/universes/v1\";\r\nexport const MESSAGING_SERVICE = \"https://apis.roblox.com/messaging-service/v1/universes\";\r\n",
  "import { int64, int32 } from \"../../types/misc/datatypes\";\r\n\r\nimport type * as DataStoreRequestHeaders from \"../../types/endpoints/datastore/request-headers\";\r\nimport type * as DataStoreQueryParams from \"../../types/endpoints/datastore/query-params\";\r\nimport type * as DataStoreResponseJSON from \"../../types/endpoints/datastore/response-json\";\r\n\r\nimport type * as MessagingServiceRequestHeaders from \"../../types/endpoints/messaging-service/request-headers\";\r\n\r\nimport * as utils from \"../../lib/utils\";\r\nimport { Pages } from \"./pages\";\r\n\r\nimport { DATA_STORE, MESSAGING_SERVICE } from \"../../config/urls\";\r\n\r\n/**\r\n * Universe is a collection of places, often referred\r\n * to as a game or an experience.\r\n */\r\nexport class Universe {\r\n\tpublic readonly id!: int64;\r\n\tpublic readonly apiKey!: string;\r\n\r\n\t/**\r\n\t * @param id Universe's id. Do not mistake it for place id.\r\n\t * @param apiKey API key; is used to authenticate API calls made to the universe.\r\n\t */\r\n\tconstructor(id: int64, apiKey: string) {\r\n\t\tthis.id = id;\r\n\t\tthis.apiKey = apiKey;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a `DataStoreListingPages` class for enumerating through all of the universe's data stores.\r\n\t * It accepts an optional prefix parameter to only locate data stores whose names start with the provided prefix.\r\n\t * @param prefix Prefix to enumerate data stores that start with the given prefix.\r\n\t * @param pageSize Number of items to be returned in each page.\r\n\t * @returns `DataStoreListingPages` class containing `DataStoreInfo` objects that provide details such as name, creation time, ~~and time last updated~~.\r\n\t */\r\n\tasync ListDataStoresAsync(prefix = \"\", pageSize: int32 = 50) {\r\n\t\tutils.mustBeString(\"Prefix\", prefix);\r\n\t\tutils.mustBeInteger(\"PageSize\", pageSize);\r\n\t\tif (pageSize > 50) throw Error(\"PageSize cannot be greater than 50\");\r\n\r\n\t\tconst rawUrl = `${DATA_STORE}/${this.id}/standard-datastores`;\r\n\r\n\t\tconst queryParams: DataStoreQueryParams.ListDataStores = {\r\n\t\t\tlimit: pageSize,\r\n\t\t\tprefix: prefix\r\n\t\t};\r\n\r\n\t\tconst headers: DataStoreRequestHeaders.ListDataStores = {\r\n\t\t\t\"x-api-key\": this.apiKey\r\n\t\t};\r\n\r\n\t\treturn new Pages<DataStoreQueryParams.ListDataStores,\r\n\t\t\tDataStoreRequestHeaders.ListDataStores,\r\n\t\t\tDataStoreResponseJSON.DataStoreInfo>(\"datastores\", rawUrl, queryParams, headers);\r\n\t}\r\n\r\n\t/**\r\n\t * This function sends the provided message to all subscribers to the topic,\r\n\t * triggering their registered callbacks to be invoked.\r\n\t * \r\n\t * Same as MessagingService:PublishAsync()\r\n\t * @param topic Determines where the message is sent.\r\n\t * @param message The data to include in the message.\r\n\t */\r\n\tasync PublishMessageAsync(topic: string, message: string) {\r\n\t\tutils.mustBeString(\"Topic\", topic);\r\n\t\tutils.mustBeString(\"Message\", message);\r\n\r\n\t\t// Disallow the use of non-alphanumeric characters in a topic name (as written in API restrictions)\r\n\t\tif (!topic.match(new RegExp(\"^[a-zA-Z0-9]*$\"))) {\r\n\t\t\tthrow Error(\"Topic name cannot contain non-alphanumeric characters\");\r\n\t\t}\r\n\r\n\t\t// Disallow topic name if it contains more than 80 characters (as written in API restrictions)\r\n\t\tif (topic.length > 80) {\r\n\t\t\tthrow Error(\"Topic name cannot contain more than 80 characters\");\r\n\t\t}\r\n\r\n\t\tconst url = `${MESSAGING_SERVICE}/${this.id}/topics/${topic}`;\r\n\r\n\t\tconst valueJSON = JSON.stringify({\r\n\t\t\tmessage: message\r\n\t\t});\r\n\r\n\t\tconst headers: MessagingServiceRequestHeaders.PublishAsync = {\r\n\t\t\t\"x-api-key\": this.apiKey,\r\n\t\t\t\"Content-Type\": \"application/json\"\r\n\t\t};\r\n\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"post\",\r\n\t\t\theaders: headers,\r\n\t\t\tbody: valueJSON\r\n\t\t});\r\n\r\n\t\tif (response.status !== 200) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn await response.text(); // If successful, it will return empty response body\r\n\t}\r\n}\r\n",
  "import type { int64 } from \"../../types/misc/datatypes\";\r\n\r\nimport type * as RequestHeaders from \"../../types/endpoints/place-mangement/request-headers\";\r\nimport type * as QueryParams from \"../../types/endpoints/place-mangement/query-params\";\r\nimport type * as ResponseJSON from \"../../types/endpoints/place-mangement/response-json\";\r\n\r\nimport { Universe } from \"../../index\";\r\nimport * as utils from \"../../lib/utils\";\r\n\r\nimport fs from \"node:fs/promises\";\r\n\r\nimport { PLACE_MANAGEMENT } from \"../../config/urls\";\r\n\r\n/**\r\n * Place is a collection of environmental building blocks,\r\n * models, scripts, UI, game logic, and everything else related\r\n * to the game's experience.\r\n */\r\nexport class Place {\r\n\tpublic readonly universe!: Universe;\r\n\tpublic readonly id!: int64;\r\n\r\n\tprivate readonly url!: string;\r\n\r\n\t/**\r\n\t * @param universe Refers to the universe to which place belongs to.\r\n\t * @param id Place's id.\r\n\t */\r\n\tconstructor(universe: Universe, id: int64) {\r\n\t\tthis.universe = universe;\r\n\t\tthis.id = id;\r\n\t\tthis.url = `${PLACE_MANAGEMENT}/${this.universe.id}/places/${this.id}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Uploads the place file via desired method to Roblox.\r\n\t * @param path Path to the place file.\r\n\t * @returns The latest version that was saved and/or published.\r\n\t */\r\n\tprivate async PushVersion(path: string, versionType: \"Saved\" | \"Published\") {\r\n\t\tutils.mustBeString(\"Path\", path);\r\n\t\tutils.mustBeString(\"VersionType\", versionType);\r\n\r\n\t\ttry {\r\n\t\t\tawait fs.access(path);\r\n\t\t} catch (e) {\r\n\t\t\tthrow Error(\"Place file either does not exist, or there is something restricting the access to it\");\r\n\t\t}\r\n\t\r\n\t\tconst fileInfo = await fs.stat(path);\r\n\t\t\r\n\t\tconst fileSizeInBytes = fileInfo.size;\r\n\t\tconst fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);\r\n\t\r\n\t\t// Note: The file size limit might change at anytime, so please report if there is a change to it\r\n\t\tif (fileSizeInMegabytes >= 100) {\r\n\t\t\tthrow Error(\"Place file cannot be larger than 100MB\");\r\n\t\t}\r\n\t\r\n\t\tconst fileData = await fs.readFile(path);\r\n\t\r\n\t\tconst queryParams: QueryParams.PushVersion = {\r\n\t\t\tversionType: versionType\r\n\t\t};\r\n\t\r\n\t\tconst url = utils.buildUrl(this.url + \"/versions\", queryParams);\r\n\t\r\n\t\tconst headers: RequestHeaders.PushVersion = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey,\r\n\t\t\t\"Content-Type\": \"application/octet-stream\"\r\n\t\t};\r\n\t\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"post\",\r\n\t\t\theaders: headers,\r\n\t\t\tbody: fileData\r\n\t\t});\r\n\t\r\n\t\tif (response.status !== 200) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\t\r\n\t\tconst data = utils.parseJSON(await response.text()) as ResponseJSON.PushVersion;\r\n\t\treturn data.versionNumber;\r\n\t}\r\n\r\n\t/**\r\n\t * Uploads and saves the place file to Roblox.\r\n\t * \r\n\t * **Changes caused by this function will be\r\n\t * only visible to the developers.**\r\n\t * \r\n\t * @param path Path to the place file.\r\n\t * @returns The latest version that was saved.\r\n\t */\r\n\tpublic async SaveAs(path: string) {\r\n\t\treturn this.PushVersion(path, \"Saved\");\r\n\t}\r\n\r\n\t/**\r\n\t * Uploads, saves, and publishes the place file to Roblox.\r\n\t * \r\n\t * **Changes caused by this function will be\r\n\t * visible to both players and the developers.**\r\n\t * \r\n\t * @param path Path to the place file.\r\n\t * @returns The latest version that was saved and published.\r\n\t */\r\n\tpublic async PublishAs(path: string) {\r\n\t\treturn this.PushVersion(path, \"Published\");\r\n\t}\r\n}\r\n",
  "import type { int64 } from \"../../types/misc/datatypes\";\r\n\r\nimport type * as RequestHeaders from \"../../types/endpoints/place-mangement/request-headers\";\r\nimport type * as QueryParams from \"../../types/endpoints/place-mangement/query-params\";\r\nimport type * as ResponseJSON from \"../../types/endpoints/place-mangement/response-json\";\r\n\r\nimport { Universe } from \"../../index\";\r\nimport * as utils from \"../../lib/utils\";\r\n\r\nimport fs from \"node:fs/promises\";\r\n\r\nimport { PLACE_MANAGEMENT } from \"../../config/urls\";\r\n\r\n/**\r\n * Place is a collection of environmental building blocks,\r\n * models, scripts, UI, game logic, and everything else related\r\n * to the game's experience.\r\n */\r\nexport class Place {\r\n\tpublic readonly universe!: Universe;\r\n\tpublic readonly id!: int64;\r\n\r\n\tprivate readonly url!: string;\r\n\r\n\t/**\r\n\t * @param universe Refers to the universe to which place belongs to.\r\n\t * @param id Place's id.\r\n\t */\r\n\tconstructor(universe: Universe, id: int64) {\r\n\t\tthis.universe = universe;\r\n\t\tthis.id = id;\r\n\t\tthis.url = `${PLACE_MANAGEMENT}/${this.universe.id}/places/${this.id}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Uploads the place file via desired method to Roblox.\r\n\t * @param path Path to the place file.\r\n\t * @returns The latest version that was saved and/or published.\r\n\t */\r\n\tprivate async PushVersion(path: string, versionType: \"Saved\" | \"Published\") {\r\n\t\tutils.mustBeString(\"Path\", path);\r\n\t\tutils.mustBeString(\"VersionType\", versionType);\r\n\r\n\t\ttry {\r\n\t\t\tawait fs.access(path);\r\n\t\t} catch (e) {\r\n\t\t\tthrow Error(\"Place file either does not exist, or there is something restricting the access to it\");\r\n\t\t}\r\n\t\r\n\t\tconst fileInfo = await fs.stat(path);\r\n\t\t\r\n\t\tconst fileSizeInBytes = fileInfo.size;\r\n\t\tconst fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);\r\n\t\r\n\t\t// Note: The file size limit might change at anytime, so please report if there is a change to it\r\n\t\tif (fileSizeInMegabytes >= 100) {\r\n\t\t\tthrow Error(\"Place file cannot be larger than 100MB\");\r\n\t\t}\r\n\t\r\n\t\tconst fileData = await fs.readFile(path);\r\n\t\r\n\t\tconst queryParams: QueryParams.PushVersion = {\r\n\t\t\tversionType: versionType\r\n\t\t};\r\n\t\r\n\t\tconst url = utils.buildUrl(this.url + \"/versions\", queryParams);\r\n\t\r\n\t\tconst headers: RequestHeaders.PushVersion = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey,\r\n\t\t\t\"Content-Type\": \"application/octet-stream\"\r\n\t\t};\r\n\t\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"post\",\r\n\t\t\theaders: headers,\r\n\t\t\tbody: fileData\r\n\t\t});\r\n\t\r\n\t\tif (response.status !== 200) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\t\r\n\t\tconst data = utils.parseJSON(await response.text()) as ResponseJSON.PushVersion;\r\n\t\treturn data.versionNumber;\r\n\t}\r\n\r\n\t/**\r\n\t * Uploads and saves the place file to Roblox.\r\n\t * \r\n\t * **Changes caused by this function will be\r\n\t * only visible to the developers.**\r\n\t * \r\n\t * @param path Path to the place file.\r\n\t * @returns The latest version that was saved.\r\n\t */\r\n\tpublic async SaveAs(path: string) {\r\n\t\treturn this.PushVersion(path, \"Saved\");\r\n\t}\r\n\r\n\t/**\r\n\t * Uploads, saves, and publishes the place file to Roblox.\r\n\t * \r\n\t * **Changes caused by this function will be\r\n\t * visible to both players and the developers.**\r\n\t * \r\n\t * @param path Path to the place file.\r\n\t * @returns The latest version that was saved and published.\r\n\t */\r\n\tpublic async PublishAs(path: string) {\r\n\t\treturn this.PushVersion(path, \"Published\");\r\n\t}\r\n}\r\n",
  "import type { int32, int64 } from \"../../types/misc/datatypes\";\r\nimport type { SortDirection } from \"../../types/misc/custom\";\r\n\r\nimport type * as RequestHeaders from \"../../types/endpoints/datastore/request-headers\";\r\nimport type * as QueryParams from \"../../types/endpoints/datastore/query-params\";\r\nimport type * as ResponseJSON from \"../../types/endpoints/datastore/response-json\";\r\n\r\nimport { Pages } from \"./pages\";\r\nimport { Universe } from \"../../index\";\r\nimport * as utils from \"../../lib/utils\";\r\n\r\nimport { DATA_STORE } from \"../../config/urls\";\r\n\r\n// TODO: Fix updatedTime\r\nexport class DataStoreKeyInfo {\r\n\tpublic readonly createdTime!: number;\r\n\t//public readonly updatedTime!: number;\r\n\tpublic readonly version!: string;\r\n\t\r\n\tprivate readonly userIds!: number[];\r\n\tprivate readonly metadata!: utils.Params;\r\n\r\n\tconstructor(response: Response) {\r\n\t\tconst createdTime = response.headers.get(\"roblox-entry-created-time\") as string;\r\n\t\t//const updatedTime = response.headers.get(\"last-modified\") as string;\r\n\t\tconst version = response.headers.get(\"roblox-entry-version\") as string;\r\n\t\tconst metadata = response.headers.get(\"roblox-entry-attributes\") as string;\r\n\t\tconst userIds = response.headers.get(\"roblox-entry-userids\") as string;\r\n\r\n\t\tthis.createdTime = new Date(createdTime).getTime(); // \"0000-00-00T00:00:00.0000000Z\" -> 0000000000000\r\n\t\t//this.updatedTime = new Date(updatedTime).getTime(); // \"0000-00-00T00:00:00.0000000Z\" -> 0000000000000\r\n\t\tthis.version = version; // \"0000000000000000.0000000000.0000000000000000.00\"\r\n\t\tthis.userIds = JSON.parse(userIds); // \"[]\" -> []\r\n\t\tthis.metadata = JSON.parse(metadata); // \"[]\" -> []\r\n\t}\r\n\r\n\tGetUserIds() {\r\n\t\treturn this.userIds;\r\n\t}\r\n\r\n\tGetMetadata() {\r\n\t\treturn this.metadata;\r\n\t}\r\n}\r\n\r\nexport class DataStoreSetOptions {\r\n\tpublic metadata!: Record<string, string>;\r\n\r\n\tconstructor(metadata: Record<string, string>) {\r\n\t\tthis.metadata = metadata;\r\n\t}\r\n\r\n\tGetMetadata() {\r\n\t\treturn this.metadata;\r\n\t}\r\n\r\n\tSetMetadata(metadata: Record<string, string>) {\r\n\t\tthis.metadata = metadata;\r\n\t}\r\n}\r\n\r\nexport class DataStoreOptions {\r\n\tpublic allScopes = false;\r\n}\r\n\r\n/**\r\n * Lets you store data that needs to persist between sessions,\r\n * such as items in a player's inventory or skill points. DataStores\r\n * are shared per experience, so any place in an experience, including\r\n * places on different servers, can access and change the same data.\r\n */\r\nexport class DataStore {\r\n\tpublic readonly universe: Universe;\r\n\tpublic readonly name: string;\r\n\tpublic readonly scope: string;\r\n\tpublic readonly options: DataStoreOptions;\r\n\r\n\tprivate readonly url: string;\r\n\r\n\t/**\r\n\t * @param universe Universe from which DataStore will be retrieved.\r\n\t * @param name Name of the data store.\r\n\t * @param scope A string specifying the scope.\r\n\t */\r\n\tconstructor(universe: Universe, name: string, scope = \"global\", options?: DataStoreOptions) {\r\n\t\tthis.universe = universe;\r\n\t\tthis.name = name;\r\n\t\tthis.scope = scope;\r\n\t\tthis.options = options || new DataStoreOptions();\r\n\t\tthis.url = `${DATA_STORE}/${this.universe.id}/standard-datastores/datastore`;\r\n\t}\r\n\r\n\t/**\r\n\t * This function returns the latest value of the provided key and a `DataStoreKeyInfo` class.\r\n\t * If the key does not exist or if the latest version has been marked as deleted, both return values will be `null`.\r\n\t * @param key The key name for which the value is requested.\r\n\t * @returns The value of the entry in the data store with the given key and a `DataStoreKeyInfo`\r\n\t * class that includes the version number, date and time the version was created, and functions to retrieve UserIds and metadata.\r\n\t */\r\n\tasync GetAsync<CustomDataType>(key: string): Promise<[CustomDataType, DataStoreKeyInfo]> {\r\n\t\tutils.mustBeString(\"Key\", key);\r\n\r\n\t\tconst queryParams: QueryParams.GetEntry = {\r\n\t\t\tdatastoreName: this.name,\r\n\t\t\tentryKey: key,\r\n\t\t};\r\n\r\n\t\tconst url = utils.buildUrl(this.url + \"/entries/entry\", queryParams);\r\n\r\n\t\tconst headers: RequestHeaders.GetEntry = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey\r\n\t\t};\r\n\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"get\",\r\n\t\t\theaders: headers\r\n\t\t});\r\n\r\n\t\tif (response.status !== 200) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tconst data = utils.parseJSON(await response.text()) as CustomDataType;\r\n\t\treturn [data, new DataStoreKeyInfo(response)];\r\n\t}\r\n\r\n\t/**\r\n\t * This function sets the latest value, UserIds, and metadata for the given key.\r\n\t * \r\n\t * **Metadata definitions must always be updated with a value, even if there are no changes to the current value; otherwise the current value will be lost.**\r\n\t * @param key Key name for which the value should be set.\r\n\t * @param value The value that the data store key will be set to.\r\n\t * @param userIds Table of `UserIds`, highly recommended to assist with GDPR tracking/removal.\r\n\t * @param options Class that allows for metadata specification on the key.\r\n\t * @returns The version identifier of the newly created version\r\n\t */\r\n\tasync SetAsync<CustomDataType>(key: string, value: CustomDataType, userIds: int64[] = [], options?: DataStoreSetOptions) {\r\n\t\tutils.mustBeString(\"Key\", key);\r\n\t\tif (value == undefined || null) throw Error(\"Value cannot be empty\");\r\n\r\n\t\tconst queryParams: QueryParams.SetEntry = {\r\n\t\t\tdatastoreName: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tentryKey: key,\r\n\t\t};\r\n\r\n\t\tconst url = utils.buildUrl(this.url + \"/entries/entry\", queryParams);\r\n\r\n\t\tconst valueJSON = JSON.stringify(value);\r\n\r\n\t\t// Possibly not accurate, but should prevent files from hitting the size limit\r\n\t\tconst dataSizeMB = Buffer.from(valueJSON).byteLength / 1e+6;\r\n\t\tif (dataSizeMB >= 4) throw Error(\"Value cannot be larger than 4MB\");\r\n\r\n\t\tconst headers: RequestHeaders.SetEntry = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey,\r\n\t\t\t\"content-md5\": utils.checksum(valueJSON),\r\n\t\t\t\"roblox-entry-userids\": JSON.stringify(userIds),\r\n\t\t\t\"roblox-entry-attributes\": (options) ? JSON.stringify(options.GetMetadata()) : \"\"\r\n\t\t};\r\n\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"post\",\r\n\t\t\theaders: headers,\r\n\t\t\tbody: valueJSON // Must be in JSON format\r\n\t\t});\r\n\r\n\t\tif (response.status !== 200) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tconst data = utils.parseJSON(await response.text()) as ResponseJSON.EntryVersionInfo;\r\n\t\treturn data.version;\r\n\t}\r\n\r\n\t/**\r\n\t * This function increments the value of a key by the provided amount (both must be integers).\r\n\t * @param key Key name for which the value should be updated.\r\n\t * @param delta Amount to increment the current value by.\r\n\t * @param userIds A table of `UserIds` to associate with the key.\r\n\t * @param options Class that combines multiple additional parameters as custom metadata and allows for future extensibility.\r\n\t * @returns The updated value of the entry in the data store with the given key.\r\n\t */\r\n\tasync IncrementAsync<CustomDataType>(key: string, delta: int32, userIds: int64[] = [], options?: DataStoreSetOptions) {\r\n\t\tutils.mustBeString(\"Key\", key);\r\n\t\tutils.mustBeInteger(\"Delta\", delta);\r\n\r\n\t\tconst queryParams: QueryParams.IncrementEntry = {\r\n\t\t\tdatastoreName: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tentryKey: key,\r\n\t\t\tincrementBy: delta\r\n\t\t};\r\n\r\n\t\tconst url = utils.buildUrl(this.url + \"/entries/entry/increment\", queryParams);\r\n\r\n\t\tconst headers: RequestHeaders.IncrementEntry = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey,\r\n\t\t\t\"roblox-entry-userids\": JSON.stringify(userIds),\r\n\t\t\t\"roblox-entry-attributes\": (options) ? JSON.stringify(options.GetMetadata()) : \"\"\r\n\t\t};\r\n\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"post\",\r\n\t\t\theaders: headers\r\n\t\t});\r\n\r\n\t\tif (response.status !== 200) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tconst data = await this.GetAsync<CustomDataType>(key);\r\n\t\treturn data;\r\n\t}\r\n\r\n\t/**\r\n\t * This function marks the specified key as deleted by creating a new \"tombstone\" version of the key.\r\n\t * @param key Key name to be removed.\r\n\t * @returns The value of the data store prior to deletion and a `DataStoreKeyInfo` class.\r\n\t */\r\n\tasync RemoveAsync(key: string) {\r\n\t\tutils.mustBeString(\"Key\", key);\r\n\r\n\t\tconst previousData = await this.GetAsync(key);\r\n\r\n\t\tconst queryParams: QueryParams.DeleteEntry = {\r\n\t\t\tdatastoreName: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tentryKey: key\r\n\t\t};\r\n\r\n\t\tconst url = utils.buildUrl(this.url + \"/entries/entry\", queryParams);\r\n\r\n\t\tconst headers: RequestHeaders.DeleteEntry = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey\r\n\t\t};\r\n\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"delete\",\r\n\t\t\theaders: headers\r\n\t\t});\r\n\r\n\t\tif (response.status !== 204) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn previousData;\r\n\t}\r\n\r\n\t/**\r\n\t * This function returns a `DataStoreKeyPages` object for enumerating through keys of a data store.\r\n\t * It accepts an optional `prefix` parameter to only locate keys whose names start with the provided `prefix`.\r\n\t * @param prefix Prefix to use for locating keys.\r\n\t * @param pageSize Number of items to be returned in each page.\r\n\t * @returns A `DataStoreKeyPages` instance that enumerates the keys as DataStoreKey instances.\r\n\t */\r\n\tasync ListKeysAsync(prefix = \"\", pageSize: int32 = 50) {\r\n\t\tutils.mustBeString(\"Prefix\", prefix);\r\n\t\tutils.mustBeInteger(\"PageSize\", pageSize);\r\n\t\tif (pageSize > 50) throw Error(\"PageSize cannot be greater than 50\");\r\n\r\n\t\tconst rawUrl = this.url + \"/entries\";\r\n\r\n\t\tconst queryParams: QueryParams.ListEntries = {\r\n\t\t\tdatastoreName: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tAllScopes: this.options.allScopes,\r\n\t\t\tlimit: pageSize,\r\n\t\t\tprefix: prefix\r\n\t\t};\r\n\r\n\t\tconst headers: RequestHeaders.ListEntries = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey\r\n\t\t};\r\n\r\n\t\t// TODO: Create class that extends Pages class, so that this line can be used: new DataStoreKeyPages(rawUrl, queryParams, headers);\r\n\t\treturn new Pages<QueryParams.ListEntries, RequestHeaders.ListEntries, ResponseJSON.EntryKeyInfo>(\"keys\", rawUrl, queryParams, headers);\r\n\t}\r\n\r\n\t/**\r\n\t * This function enumerates versions of the specified key in either ascending or descending order specified by a SortDirection parameter.\r\n\t * It can optionally filter the returned versions by minimum and maximum timestamp.\r\n\t * @param key Key name for the versions to list.\r\n\t * @param sortDirection Sort order of the versions.\r\n\t * @param minDate Date after which the versions should be listed.\r\n\t * @param maxDate Date up to which the versions should be listed.\r\n\t * @param pageSize Number of items to be returned in each page.\r\n\t * @returns A `DataStoreVersionPages` class that enumerates all the versions of the key as `DataStoreObjectVersionInfo` classes.\r\n\t */\r\n\tasync ListVersionsAsync(key: string, sortDirection: SortDirection = \"Ascending\", minDate: int64 = 0, maxDate: int64 = 0, pageSize: int32 = 50) {\r\n\t\tutils.mustBeString(\"Key\", key);\r\n\t\tutils.mustBeString(\"SortDirection\", sortDirection);\r\n\t\tutils.mustBeInteger(\"MinDate\", minDate);\r\n\t\tutils.mustBeInteger(\"MaxDate\", maxDate);\r\n\t\tutils.mustBeInteger(\"PageSize\", pageSize);\r\n\t\tif (sortDirection !== \"Ascending\" && sortDirection !== \"Descending\") {\r\n\t\t\tthrow Error(\"SortDirection must be either Ascending or Descending\");\r\n\t\t}\r\n\r\n\t\tconst rawUrl = this.url + \"/entries/entry/versions\";\r\n\r\n\t\tconst queryParams: QueryParams.ListEntryVersions = {\r\n\t\t\tdatastoreName: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tentryKey: key,\r\n\t\t\tsortOrder: sortDirection,\r\n\t\t\tlimit: pageSize\r\n\t\t};\r\n\r\n\t\tif (minDate !== 0) queryParams.startTime = new Date(minDate).toISOString();\r\n\t\tif (maxDate !== 0) queryParams.endTime =  new Date(maxDate).toISOString();\r\n\r\n\t\tconst headers: RequestHeaders.ListEntryVersions = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey\r\n\t\t};\r\n\r\n\t\treturn new Pages<QueryParams.ListEntryVersions, RequestHeaders.ListEntryVersions, ResponseJSON.EntryVersionInfo>(\"versions\", rawUrl, queryParams, headers);\r\n\t}\r\n\r\n\t/**\r\n\t * This function retrieves the specified key version as well as a `DataStoreKeyInfo` instance.\r\n\t * @param key Key name for which the version info is requested.\r\n\t * @param version Version number of the key for which the version info is requested.\r\n\t * @returns The value of the entry in the data store with the given key and a `DataStoreKeyInfo`\r\n\t * class that includes the version number, date and time the version was created, and functions to retrieve UserIds and metadata.\r\n\t */\r\n\tasync GetVersionAsync<CustomDataType>(key: string, version: string) {\r\n\t\tutils.mustBeString(\"Key\", key);\r\n\t\tutils.mustBeString(\"Version\", version);\r\n\r\n\t\tconst queryParams: QueryParams.GetEntryVersion = {\r\n\t\t\tdatastoreName: this.name,\r\n\t\t\tentryKey: key,\r\n\t\t\tversionId: version\r\n\t\t};\r\n\r\n\t\tconst url = utils.buildUrl(this.url + \"/entries/entry/versions/version\", queryParams);\r\n\r\n\t\tconst headers: RequestHeaders.GetEntryVersion = {\r\n\t\t\t\"x-api-key\": this.universe.apiKey\r\n\t\t};\r\n\r\n\t\tconst response = await fetch(url, {\r\n\t\t\tmethod: \"get\",\r\n\t\t\theaders: headers\r\n\t\t});\r\n\r\n\t\tif (response.status !== 200) {\r\n\t\t\treturn Promise.reject({\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\tstatusText: response.statusText\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tconst data = utils.parseJSON(await response.text()) as CustomDataType;\r\n\t\treturn [data, new DataStoreKeyInfo(response)];\r\n\t}\r\n}\r\n",
  "type Info = {\r\n\turl: string,\r\n\tmethod: \"GET\" | \"POST\" | \"PATCH\" | \"DELETE\"\r\n\tquery: {\r\n\t\t[index: string]: string | number | boolean | null | undefined\r\n\t},\r\n\theaders: {\r\n\t\t[index: string]: string\r\n\t},\r\n\tbody?: string\r\n}\r\n\r\nexport async function request(info: Info) {\r\n\tconst query = new URLSearchParams();\r\n\tfor (const [key, value] of Object.entries(info.query)) {\r\n\t\tif (value) {\r\n\t\t\tif (typeof(value) === \"string\") {\r\n\t\t\t\tquery.append(key, value);\r\n\t\t\t} else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\r\n\t\t\t\tquery.append(key, value.toString());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst response = await fetch(info.url + \"?\" + query.toString(), {\r\n\t\tmethod: info.method,\r\n\t\theaders: info.headers,\r\n\t\tbody: info.body\r\n\t});\r\n\r\n\treturn response;\r\n}\r\n",
  "import * as http from \"../../lib/http\";\r\n\r\nimport { ORDERED_DATA_STORE } from \"../../config/urls\";\r\n\r\ntype ListObject = {\r\n\txApiKey: string,\r\n\tuniverseId: string,\r\n\torderedDataStore: string,\r\n\tscope: string,\r\n\tmaxPageSize?: number,\r\n\tpageToken?: string,\r\n\torderBy?: \"asc\" | \"desc\",\r\n\tfilter?: string\r\n}\r\n\r\nexport type ListReturn = {\r\n\tentries: {\r\n\t\tpath: string,\r\n\t\tvalue: number,\r\n\t\tid: string\r\n\t}[],\r\n\tnextPageToken: string\r\n}\r\n\r\n/**\r\n * Returns a list of entries from an ordered data store.\r\n */\r\nexport async function listEntries({\r\n\txApiKey,\r\n\tuniverseId,\r\n\torderedDataStore,\r\n\tscope,\r\n\tmaxPageSize,\r\n\tpageToken,\r\n\torderBy,\r\n\tfilter\r\n}: ListObject) {\r\n\tconst response = await http.request({\r\n\t\turl: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries`,\r\n\t\tmethod: \"GET\",\r\n\t\theaders: {\r\n\t\t\t\"x-api-key\": xApiKey\r\n\t\t},\r\n\t\tquery: {\r\n\t\t\tmax_page_size: maxPageSize,\r\n\t\t\tpage_token: pageToken,\r\n\t\t\torder_by: orderBy,\r\n\t\t\tfilter: filter\r\n\t\t}\r\n\t});\r\n\r\n\treturn await response.json() as ListReturn;\r\n}\r\n\r\ntype CreateObject = {\r\n\txApiKey: string,\r\n\tuniverseId: string,\r\n\torderedDataStore: string,\r\n\tscope: string,\r\n\tid: string,\r\n\tvalue: number\r\n}\r\n\r\nexport type CreateReturn = {\r\n\tpath: string,\r\n\tid: string,\r\n\tvalue: number\r\n}\r\n\r\n/**\r\n * Creates a new entry with the content value provided.\r\n */\r\nexport async function createEntry({\r\n\txApiKey,\r\n\tuniverseId,\r\n\torderedDataStore,\r\n\tscope,\r\n\tid,\r\n\tvalue\r\n}: CreateObject) {\r\n\tconst response = await http.request({\r\n\t\turl: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries`,\r\n\t\tmethod: \"POST\",\r\n\t\theaders: {\r\n\t\t\t\"x-api-key\": xApiKey,\r\n\t\t\t\"Content-Type\": \"application/json\"\r\n\t\t},\r\n\t\tquery: {\r\n\t\t\tid\r\n\t\t},\r\n\t\tbody: JSON.stringify({\r\n\t\t\tvalue\r\n\t\t})\r\n\t});\r\n\r\n\treturn await response.json() as CreateReturn;\r\n}\r\n\r\ntype GetObject = {\r\n\txApiKey: string,\r\n\tuniverseId: string,\r\n\torderedDataStore: string,\r\n\tscope: string,\r\n\tentry: string\r\n}\r\n\r\nexport type GetReturn = {\r\n\tpath: string,\r\n\tid: string,\r\n\tvalue: number\r\n}\r\n\r\n/**\r\n * Gets and returns the specified entry.\r\n */\r\nexport async function getEntry({\r\n\txApiKey,\r\n\tuniverseId,\r\n\torderedDataStore,\r\n\tscope,\r\n\tentry\r\n}: GetObject) {\r\n\tconst response = await http.request({\r\n\t\turl: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries/${entry}`,\r\n\t\tmethod: \"GET\",\r\n\t\theaders: {\r\n\t\t\t\"x-api-key\": xApiKey\r\n\t\t},\r\n\t\tquery: {}\r\n\t});\r\n\r\n\treturn await response.json() as GetReturn;\r\n}\r\n\r\ntype DeleteObject = {\r\n\txApiKey: string,\r\n\tuniverseId: string,\r\n\torderedDataStore: string,\r\n\tscope: string,\r\n\tentry: string\r\n}\r\n\r\n/**\r\n * Deletes the specified entry.\r\n */\r\nexport async function deleteEntry({\r\n\txApiKey,\r\n\tuniverseId,\r\n\torderedDataStore,\r\n\tscope,\r\n\tentry\r\n}: DeleteObject) {\r\n\tawait http.request({\r\n\t\turl: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries/${entry}`,\r\n\t\tmethod: \"DELETE\",\r\n\t\theaders: {\r\n\t\t\t\"x-api-key\": xApiKey\r\n\t\t},\r\n\t\tquery: {}\r\n\t});\r\n}\r\n\r\ntype UpdateObject = {\r\n\txApiKey: string,\r\n\tuniverseId: string,\r\n\torderedDataStore: string,\r\n\tscope: string,\r\n\tentry: string,\r\n\tvalue: number,\r\n\t/**\r\n\t * The flag to allow the creation of an entry if the entry doesn't exist.\r\n\t */\r\n\tallowMissing: boolean\r\n}\r\n\r\nexport type UpdateReturn = {\r\n\tpath: string,\r\n\tid: string,\r\n\tvalue: number\r\n}\r\n\r\n/**\r\n * Updates an entry value and returns the updated entry.\r\n */\r\nexport async function updateEntry({\r\n\txApiKey,\r\n\tuniverseId,\r\n\torderedDataStore,\r\n\tscope,\r\n\tentry,\r\n\tvalue,\r\n\tallowMissing\r\n}: UpdateObject) {\r\n\tconst response = await http.request({\r\n\t\turl: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries/${entry}`,\r\n\t\tmethod: \"PATCH\",\r\n\t\theaders: {\r\n\t\t\t\"x-api-key\": xApiKey,\r\n\t\t\t\"Content-Type\": \"application/json\"\r\n\t\t},\r\n\t\tquery: {\r\n\t\t\tallow_missing: allowMissing\r\n\t\t},\r\n\t\tbody: JSON.stringify({\r\n\t\t\tvalue\r\n\t\t})\r\n\t});\r\n\r\n\treturn await response.json() as UpdateReturn;\r\n}\r\n\r\ntype IncrementObject = {\r\n\txApiKey: string,\r\n\tuniverseId: string,\r\n\torderedDataStore: string,\r\n\tscope: string,\r\n\tentry: string,\r\n\r\n\t/**\r\n\t * The amount to increment by the entry value.\r\n\t * If the input value exceeds the maximum value\r\n\t * supported by int64,which is 9,223,372,036,854,775,807,\r\n\t * the request fails with a 400 Bad Request error.\r\n\t */\r\n\tamount: number,\r\n}\r\n\r\nexport type IncrementReturn = {\r\n\tpath: string,\r\n\tid: string,\r\n\tvalue: number\r\n}\r\n\r\n/**\r\n * Updates an entry value and returns the updated entry.\r\n */\r\nexport async function incrementEntry({\r\n\txApiKey,\r\n\tuniverseId,\r\n\torderedDataStore,\r\n\tscope,\r\n\tentry,\r\n\tamount\r\n}: IncrementObject) {\r\n\tconst response = await http.request({\r\n\t\turl: `${ORDERED_DATA_STORE}/v1/universes/${universeId}/orderedDataStores/${orderedDataStore}/scopes/${scope}/entries/${entry}:increment`,\r\n\t\tmethod: \"POST\",\r\n\t\theaders: {\r\n\t\t\t\"x-api-key\": xApiKey,\r\n\t\t\t\"Content-Type\": \"application/json\"\r\n\t\t},\r\n\t\tquery: {},\r\n\t\tbody: JSON.stringify({\r\n\t\t\tamount\r\n\t\t})\r\n\t});\r\n\r\n\treturn await response.json() as IncrementReturn;\r\n}\r\n",
  "import { Universe } from \"./universe\";\r\nimport * as raw from \"../cloud/ordered-data-store\";\r\n\r\ntype DataStoreListingInfo = {\r\n\tuniverse: Universe,\r\n\tname: string,\r\n\tscope: string,\r\n\tascending: boolean,\r\n\tpageSize: number\r\n}\r\n\r\nexport class DataStorePages {\r\n\tprivate entries: {\r\n\t\tpath: string;\r\n\t\tvalue: number;\r\n\t\tid: string;\r\n\t}[];\r\n\r\n\tprivate readonly info: DataStoreListingInfo;\r\n\tprivate nextPageToken: string;\r\n\tpublic IsFinished: boolean;\r\n\r\n\tpublic constructor(info: DataStoreListingInfo, data: raw.ListReturn) {\r\n\t\tthis.info = info;\r\n\t\tthis.entries = data.entries;\r\n\t\tthis.nextPageToken = data.nextPageToken;\r\n\t\tthis.IsFinished = this.nextPageToken === \"\";\r\n\t}\r\n\r\n\tpublic GetCurrentPage() {\r\n\t\treturn this.entries.map(v => {\r\n\t\t\treturn {\r\n\t\t\t\tkey: v.id,\r\n\t\t\t\tvalue: v.value\r\n\t\t\t};\r\n\t\t});\r\n\t}\r\n\r\n\tpublic async AdvanceToNextPageAsync() {\r\n\t\tif (this.IsFinished) return;\r\n\t\t\r\n\t\tconst response = await raw.listEntries({\r\n\t\t\txApiKey: this.info.universe.apiKey,\r\n\t\t\tuniverseId: this.info.universe.id.toString(),\r\n\t\t\torderedDataStore: this.info.name,\r\n\t\t\tscope: this.info.scope,\r\n\t\t\torderBy: this.info.ascending ? \"asc\" : \"desc\",\r\n\t\t\tmaxPageSize: this.info.pageSize,\r\n\t\t\tpageToken: this.nextPageToken\r\n\t\t});\r\n\r\n\t\tthis.entries = response.entries;\r\n\t\tthis.nextPageToken = response.nextPageToken;\r\n\t\tthis.IsFinished = this.nextPageToken === \"\";\r\n\t}\r\n}\r\n\r\nexport class OrderedDataStore {\r\n\tpublic readonly universe: Universe;\r\n\tprivate readonly name: string;\r\n\tprivate readonly scope: string;\r\n\r\n\tpublic constructor(universe: Universe, name: string, scope = \"global\") {\r\n\t\tthis.universe = universe;\r\n\t\tthis.name = name;\r\n\t\tthis.scope = scope;\r\n\t}\r\n\r\n\tpublic async GetSortedAsync(ascending: boolean, pageSize: number) {\r\n\t\tconst data = await raw.listEntries({\r\n\t\t\txApiKey: this.universe.apiKey,\r\n\t\t\tuniverseId: this.universe.id.toString(),\r\n\t\t\torderedDataStore: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\torderBy: ascending ? \"asc\" : \"desc\",\r\n\t\t\tmaxPageSize: pageSize,\r\n\t\t});\r\n\r\n\t\tconst info: DataStoreListingInfo = {\r\n\t\t\tuniverse: this.universe,\r\n\t\t\tname: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tascending,\r\n\t\t\tpageSize\r\n\t\t};\r\n\t\t\r\n\t\treturn new DataStorePages(info, data);\r\n\t}\r\n\r\n\tpublic async SetAsync(key: string, value: number) {\r\n\t\tawait raw.createEntry({\r\n\t\t\txApiKey: this.universe.apiKey,\r\n\t\t\tuniverseId: this.universe.id.toString(),\r\n\t\t\torderedDataStore: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tid: key,\r\n\t\t\tvalue\r\n\t\t});\r\n\t}\r\n\r\n\tpublic async GetAsync(key: string) {\r\n\t\tconst data = await raw.getEntry({\r\n\t\t\txApiKey: this.universe.apiKey,\r\n\t\t\tuniverseId: this.universe.id.toString(),\r\n\t\t\torderedDataStore: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tentry: key\r\n\t\t});\r\n\t\t\r\n\t\treturn data.value;\r\n\t}\r\n\r\n\tpublic async RemoveAsync(key: string) {\r\n\t\tawait raw.deleteEntry({\r\n\t\t\txApiKey: this.universe.apiKey,\r\n\t\t\tuniverseId: this.universe.id.toString(),\r\n\t\t\torderedDataStore: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tentry: key\r\n\t\t});\r\n\t}\r\n\r\n\t/*\r\n\tpublic async UpdateAsync(\r\n\t\tkey: string,\r\n\t\ttransformFunction: (currentValue: number) => number | undefined | null | void\r\n\t): Promise<number | void> {\r\n\t\tconst getResponse = await raw.getEntry({\r\n\t\t\txApiKey: this.universe.apiKey,\r\n\t\t\tuniverseId: this.universe.id.toString(),\r\n\t\t\torderedDataStore: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tentry: key,\r\n\t\t});\r\n\t\t\r\n\t\tconst returnedValue = transformFunction(getResponse.value);\r\n\t\tif (typeof(returnedValue) === \"number\") {\r\n\t\t\tconst updateResponse = await raw.updateEntry({\r\n\t\t\t\txApiKey: this.universe.apiKey,\r\n\t\t\t\tuniverseId: this.universe.id.toString(),\r\n\t\t\t\torderedDataStore: this.name,\r\n\t\t\t\tscope: this.scope,\r\n\t\t\t\tentry: key,\r\n\t\t\t\tvalue: returnedValue,\r\n\t\t\t\tallowMissing: false\r\n\t\t\t});\r\n\r\n\t\t\treturn updateResponse.value;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic async IncrementAsync(key: string, delta: number) {\r\n\t\tconst data = await raw.incrementEntry({\r\n\t\t\txApiKey: this.universe.apiKey,\r\n\t\t\tuniverseId: this.universe.id.toString(),\r\n\t\t\torderedDataStore: this.name,\r\n\t\t\tscope: this.scope,\r\n\t\t\tentry: key,\r\n\t\t\tamount: delta\r\n\t\t});\r\n\t\t\r\n\t\treturn data.value;\r\n\t}\r\n\t*/\r\n}\r\n"
  ],
  "mappings": "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",
  "debugId": "7D7AAEF9F35C710264756e2164756e21",
  "names": []
}